{"version":3,"sources":["logic/AudioManager.ts","components/dashboard_components/SampleComponent.tsx","components/dashboard_components/SoundGraph.tsx","components/dashboard_components/Recorder.tsx","components/Dashboard.tsx","components/Sidebar.tsx","components/App.tsx","reportWebVitals.ts","index.tsx"],"names":["emptyBuffer","Float32Array","AudioManager","audioContext","_nodes","nodeConnections","analyser","_timeBuffer","_freqBuffer","source","audioStream","audioActive","FFT_SIZE","SAMPLE_RATE","addSourceNode","MediaStreamAudioSourceNode","mediaStream","addNode","outputs","this","window","AudioContext","sampleRate","analyzer","AnalyserNode","fftSize","active","navigator","mediaDevices","getUserMedia","audio","video","getTracks","every","track","enabled","forEach","getTimeData","bind","getFreqData","a","initAudio","bigIfTrue","getFloatTimeDomainData","getFloatFrequencyData","node","key","conn","Error","inputs","inputKey","connectNodes","outputKey","srcNodeKey","dstNodeKey","connect","SampleComponent","forwardRef","ref","className","style","props","children","text","textAlign","SoundGraph","movement_timer","canvasRef","useRef","containerRef","useState","dimensions","setDimensions","test_dimensions","current","width","offsetWidth","height","offsetHeight","useLayoutEffect","addEventListener","clearInterval","setTimeout","displayGraph","isRecording","canvas","getContext","setAttribute","toString","context","audioData","x","sliceWidth","length","idx","lineWidth","strokeStyle","clearRect","y","r","fillRect","draw","soundData","icons","recordOn","size","recordOff","pauseOn","pauseOff","Recorder","setIsRecording","setSoundData","intervalId","setIntervalId","recordingIcon","updateTimeData","useCallback","timeData","audioManager","updatePeriod","useEffect","interval","setInterval","onClick","newRecordingState","startRecording","console","log","stopRecording","ReactGridLayout","WidthProvider","RGL","gridProps","rowHeight","cols","verticalCompact","isBounded","onLayoutChange","defaultDashboardLayout","temp1","element","layout","i","w","h","temp2","recorderLayout","static","Dashboard","dshbLayout","builtElements","useMemo","components","map","comp","createElement","timeLog","menuClosed","menuOpen","library","settings","sourceCode","contact","Sidebar","isMobile","isClosed","setIsClosed","title","openCloseIcon","collapsed","iconShape","icon","href","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0171d7e9.chunk.js","sourcesContent":["\n\n// A string-indexed list of nodes. Essentially a dict\ninterface INodes {\n  [key: string]: AudioNode;\n}\n\n// \ntype nodeKey = keyof INodes;\n\n// A string-indexed list of nodes. Essentially a dict\ninterface INodeConnections {\n  [src: nodeKey]: nodeKey;\n}\n\nconst emptyBuffer = new Float32Array(0);\n\n\nclass AudioManager {\n  // audio state and analysis\n  audioContext?: AudioContext;\n\n  _nodes: INodes; // essentially a dictionary of nodes\n  nodeConnections: INodeConnections;\n\n  analyser?: AnalyserNode | null;\n  _timeBuffer: Float32Array;\n  _freqBuffer: Float32Array;\n\n  source?: MediaStreamAudioSourceNode | null;\n\n\n  audioStream?: MediaStream | null;\n\n  audioActive: boolean = false; // if we're actively processing audio\n  readonly FFT_SIZE = 2048; // num bins in fft -- real + image\n  readonly SAMPLE_RATE = 16000;\n\n  public get nodes() {\n    return this._nodes;\n  }\n\n\n  constructor() {\n    this._nodes = {};\n    this.nodeConnections = {};\n\n    this._timeBuffer = new Float32Array(this.FFT_SIZE);\n    this._freqBuffer = new Float32Array(this.FFT_SIZE / 2);\n  }\n\n  // Initializes the audio context and nodes. Must be called from a user gesture\n  //TODO: How to avoid re-doing this w/ every click?\n  private async initAudio(): Promise<boolean> {\n    // audio context must be created in a user gesture\n    if (this.audioContext == null) {\n      this.audioContext = new window.AudioContext({ sampleRate: this.SAMPLE_RATE });\n    }\n\n    // Initialize analyzer node\n\n    if (this._nodes['analyzer'] == null) {\n      let analyzer = new AnalyserNode(this.audioContext, { fftSize: this.FFT_SIZE });\n      this.addNode(analyzer, \"analyzer\");\n    }\n\n    if (this.audioStream == null || !this.audioStream?.active) {\n      this.audioStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n      this.addSourceNode();\n    } else if (this.audioStream?.getTracks().every((track) => track.enabled == false)) {\n      this.audioStream?.getTracks().forEach(track => track.enabled = true);\n    }\n\n\n    if (this._nodes['source'] == null) {\n      this.addSourceNode();\n    }\n\n    // Lets them be used in callbacks\n    this.getTimeData.bind(this);\n    this.getFreqData.bind(this);\n\n    return true;\n  }\n\n  /*\n  ==== Audio input ===== \n  */\n\n  async startRecording(): Promise<boolean> {\n    let bigIfTrue = await this.initAudio();\n    this.audioActive = bigIfTrue;\n    return bigIfTrue;\n  }\n\n\n  stopRecording(): void {\n    this.audioStream?.getTracks().forEach(track => track.enabled = false);\n    this.audioActive = false;\n  }\n\n\n  public getTimeData(): Float32Array {\n    let analyzer = this._nodes['analyzer'];\n    if (analyzer instanceof AnalyserNode) {\n      // TODO: this has weird behavior... doesn't always output right thing\n      analyzer.getFloatTimeDomainData(this._timeBuffer);\n      return this._timeBuffer;\n    }\n    return emptyBuffer;\n  }\n\n  public getFreqData(): Float32Array {\n    let analyzer = this._nodes['analyzer'];\n    if (analyzer instanceof AnalyserNode) {\n      analyzer.getFloatFrequencyData(this._freqBuffer);\n      return this._freqBuffer;\n    }\n    return emptyBuffer;\n  }\n\n\n  /*\n  ==== Audio graph structure ===== \n  */\n\n  public addNode(node: AudioNode, key: string, conn?: { inputs?: string[], outputs?: string[] }) {\n    if (key in this._nodes) {\n      throw new Error(\"Key already exists in audio graph\");\n    }\n    this._nodes[key] = node;\n\n    // connect the inputs for this node to it\n    if (conn?.inputs) {\n      conn.inputs.forEach((inputKey) => this.connectNodes(inputKey, key));\n    }\n\n    // connect this node to the ones it outputs to\n    if (conn?.outputs) {\n      conn.outputs.forEach((outputKey) => this.connectNodes(key, outputKey));\n    }\n  }\n\n  public nodeExists(key: string) {\n    return key in this._nodes;\n  }\n\n  // conencts two audio nodes -- true on success\n  private connectNodes(srcNodeKey: nodeKey, dstNodeKey: nodeKey) {\n    if (!(srcNodeKey in this._nodes) && !(dstNodeKey in this._nodes)) {\n      throw new Error(\"At least one provided key is invalid\");\n    }\n\n    this._nodes[srcNodeKey].connect(this._nodes[dstNodeKey]);\n    this.nodeConnections[srcNodeKey] = dstNodeKey;\n  }\n\n\n  private addSourceNode = () => {\n    if (this.audioContext && this.audioStream) {\n      let source = new MediaStreamAudioSourceNode(this.audioContext, { mediaStream: this.audioStream });\n      this.addNode(source, \"source\", { outputs: [\"analyzer\"] });\n    }\n  }\n\n}\n\nexport default AudioManager;","import { forwardRef, FunctionComponent } from \"react\";\nimport { IDashboardComponentProps } from \"./DshbComp\";\n\ninterface SampleComponentProps extends IDashboardComponentProps {\n  text?: string;\n}\n\nconst boxStyle = { textAlign: 'center' };\n\nconst SampleComponent: FunctionComponent<SampleComponentProps>\n  = forwardRef(({ className, style = {}, children, ...props }, ref) => {\n    let { text = \"Hi there\" } = props;\n    return (\n      <div {...props}\n        style={{ ...style }}\n        className={className + \" recorder\"}\n        ref={ref as React.RefObject<HTMLDivElement>}>\n        <div style={{ textAlign: 'center' }}> {text} </div>\n      </div>\n    );\n  });\n\nexport default SampleComponent;","import { FunctionComponent, useEffect, useLayoutEffect, useMemo, useRef, useState } from \"react\";\n\n\ninterface ISoundGraphProps {\n  soundData: Float32Array;\n  isRecording: boolean;\n}\n\ninterface IDimensions {\n  width: number;\n  height: number;\n}\n\nconst toPower = (db: number) => 10^(db/10);\n\nfunction draw(context: CanvasRenderingContext2D, audioData: Float32Array,\n  width: number, height: number\n) {\n  let x = 0;\n  const sliceWidth = width / audioData.length;\n\n  context.lineWidth = 2;\n  context.strokeStyle = '#000000';\n  context.clearRect(0, 0, width, height);\n  context.strokeStyle = '#ffffff';\n  // context.fillRect(20, 20, width, height);\n\n\n  // TODO: filter data\n  for (const idx in audioData) {\n    const y = audioData[idx] * height + height/2;\n    // if (idx == \"100\")\n    //   console.log(idx, y);\n    let r = sliceWidth * 5;\n    context.fillRect(x, y, r, r);\n    // context.ellipse(x,y,r,r,0,0,0);\n    x += sliceWidth;\n  }\n\n\n}\n\nconst SoundGraph: FunctionComponent<ISoundGraphProps> = (props: ISoundGraphProps) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n\n  const [dimensions, setDimensions] = useState<IDimensions>();\n\n  // holds the timer for setTimeout and clearInterval\n  let movement_timer: NodeJS.Timer;\n\n  // the number of ms the window size must stay the same size before the\n  // dimension state variable is reset\n  const RESET_TIMEOUT = 100;\n\n  const test_dimensions = () => {\n    // For some reason targetRef.current.getBoundingClientRect was not available\n    // I found this worked for me, but unfortunately I can't find the\n    // documentation to explain this experience\n    // console.log(\"updating w/h\");\n\n    if (containerRef.current) {\n      setDimensions({\n        width: containerRef.current.offsetWidth,\n        height: containerRef.current.offsetHeight\n      });\n      // console.log(containerRef.current.offsetWidth,\n      //   containerRef.current.offsetHeight);\n\n    }\n  }\n\n  // This sets the dimensions on the first render\n  useLayoutEffect(() => {\n    test_dimensions();\n  }, []);\n\n  // every time the window is resized, the timer is cleared and set again\n  // the net effect is the component will only reset after the window size\n  // is at rest for the duration set in RESET_TIMEOUT.  This prevents rapid\n  // redrawing of the component for more complex components such as charts\n  window.addEventListener('resize', () => {\n    clearInterval(movement_timer);\n    if (!movement_timer) {\n      // clearInterval(movement_timer);\n\n      movement_timer = setTimeout(test_dimensions, RESET_TIMEOUT);\n    }\n  });\n\n\n\n  // let width = containerRef?.current?.offsetWidth;\n  // let height = containerRef?.current?.offsetHeight;\n  if (dimensions != null) {\n    // console.log(\"timegraph rendered\", dimensions);\n  }\n\n\n  // Redraw canvas on new sound data\n  let displayGraph = props.isRecording && dimensions != null;\n  useLayoutEffect(() => {\n    if (displayGraph) {\n      let { width, height } = dimensions!;\n      const canvas = canvasRef.current?.getContext('2d');\n\n      if (canvas != null) {\n        canvasRef.current!.setAttribute(\"width\", width.toString());\n        canvasRef.current!.setAttribute(\"height\", height.toString());\n        draw(canvas, props.soundData, width, height);\n      }\n      // console.log(\"drew canvase\");\n\n    }\n    // console.log('w/h: ', {\n    //   width: containerRef.current?.offsetWidth,\n    //   height: containerRef.current?.offsetHeight\n    // })\n  }, [dimensions?.width, dimensions?.height, props.soundData[0]]);\n\n\n\n  return (\n    <div className=\"timeDomGraph\" ref={containerRef}>\n      { // draw if width and height are set\n        displayGraph &&\n        <canvas ref={canvasRef} width={dimensions!.width} height={dimensions!.height} />\n      }\n    </div>\n  );\n}\n\nexport default SoundGraph;","import { time } from \"console\";\nimport { FunctionComponent, useState, forwardRef, useEffect, useCallback } from \"react\";\nimport { Layout } from \"react-grid-layout\";\n\nimport { TiMediaRecord, TiMediaRecordOutline, TiMediaPauseOutline, TiMediaPlayOutline } from \"react-icons/ti\";\nimport AudioManager from \"../../logic/AudioManager\";\nimport { IDashboardComponentProps } from \"./DshbComp\";\nimport SoundGraph from \"./SoundGraph\";\n\nconst icons = {\n  recordOn: <TiMediaRecord size={100} />,\n  recordOff: <TiMediaRecordOutline size={100} />,\n  pauseOn: <TiMediaPlayOutline size={100} />,\n  pauseOff: <TiMediaPauseOutline size={100} />\n};\n\n\n\n\nexport interface IRecorderProps extends IDashboardComponentProps {\n  audioManager: AudioManager;\n}\n\nconst Recorder: FunctionComponent<IRecorderProps> = forwardRef(({ className, style = {}, children, ...props }, ref) => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [soundData, setSoundData] = useState(new Float32Array(0));\n  const [intervalId, setIntervalId] = useState<NodeJS.Timeout>();\n\n  // display properties\n  let recordingIcon = isRecording ? icons.recordOn : icons.recordOff;\n  let playPauseIcon = isPlaying ? icons.pauseOff : icons.pauseOn;\n  let recordingText = isRecording ? \"Recording...\" : \"  \";\n\n  // functions\n  let onPlayPauseClick = () => setIsPlaying(!isPlaying);\n\n  let recordingStatus = useCallback(() => updateTimeData, []);\n\n\n  let onRecordClick = () => {\n    let newRecordingState = !isRecording;\n    if (newRecordingState) {\n      props.audioManager.startRecording();\n      console.log(\"\\n\\nstarted\\n\")\n    }\n    else {\n      props.audioManager.stopRecording();\n      console.log(\"\\n\\nstopped\\n\")\n    }\n    setIsRecording(newRecordingState);\n  };\n  \n\n  const updateTimeData = () => {\n    let timeData = props.audioManager.getTimeData();\n    setSoundData(new Float32Array(timeData));\n    // console.group(\"timeData\");\n    // console.log(\"isRecording: \", isRecording);\n    // console.log(timeData.slice(0, 3));\n    // console.log(timeData.length);\n    // console.groupEnd();\n    // console.log(timeData == soundData);\n    // console.log(soundData[0], soundData.length);\n  };\n  // console.log(\"recorder rendered: \", soundData[0], soundData.length);\n  // logic\n  let updatePeriod =  props.audioManager.FFT_SIZE / props.audioManager.SAMPLE_RATE;\n\n\n  // start timer when record is hit -- stop it once is record is off\n  useEffect(() => {\n    if (isRecording) {\n      const interval = setInterval(updateTimeData, updatePeriod);\n      setIntervalId(interval);\n    }\n    else if (intervalId != null) {\n      clearInterval(intervalId);\n    }\n  }, [isRecording]);\n\n\n\n// could use key={soundData[0]} and other keys to only rerender sound graph\n  return (\n    <div\n      {...props}\n      style={{ ...style }}\n      className={className + \" recorder\"}\n      ref={ref as React.RefObject<HTMLDivElement>}\n    >\n      <div className=\"recorder-controls\">\n        <div onClick={onRecordClick}>{recordingIcon}</div>\n        {/* <p>{recordingText}</p> */}\n      </div>\n\n      <SoundGraph soundData={soundData} isRecording={isRecording}/>\n\n      {/* <div onClick={onPlayPauseClick}>{playPauseIcon}</div> */}\n\n      {children}\n    </div>\n  );\n});\n\nexport default Recorder;","import { cloneElement, createElement, FunctionComponent, ReactElement, useEffect, useMemo, useState } from \"react\";\nimport \"../assets/App.css\";\n\n// grid\nimport RGL, { Layout, ReactGridLayoutProps, WidthProvider } from 'react-grid-layout';\nimport '../assets/grid_styles.css';\nimport '../assets/resizable_styles.css';\nimport AudioManager from \"../logic/AudioManager\";\nimport SampleComponent from \"./dashboard_components/SampleComponent\";\nimport Recorder, { IRecorderProps } from \"./dashboard_components/Recorder\";\n\n\nconst ReactGridLayout = WidthProvider(RGL);\n\n\n/*\n =========== types\n*/\n\n\nexport interface IGridComponent<T> {\n  element: FunctionComponent<T>;\n  props: T;\n  layout: Layout;\n  children?: React.ReactNode[];\n}\n\ninterface IDashboardProps {\n}\n\n/*\n =========== constants\n*/\n\nconst gridProps: ReactGridLayoutProps = {\n  // layout: defaultLayouts.lg,\n  rowHeight: 200,\n  cols: 3,\n  verticalCompact: true,\n  isBounded: true,\n  onLayoutChange: function () { },\n};\n\nconst defaultDashboardLayout: { [key: string]: IGridComponent<any> } = {\n  temp1: {\n    element: SampleComponent,\n    props: {},\n    layout: { i: '1', x: 0, y: 0, w: 1, h: 1 }\n  },\n  temp2: {\n    element: SampleComponent,\n    props: {},\n    layout: { i: '2', x: 1, y: 1, w: 1, h: 1 }\n  }\n};\n\n\nconst recorderLayout = { i: 'recorder', x: 0, y: 0, w: 3, h: 1, static: true };\n\n\n/*\n =========== functions\n*/\n\n// applys the layouts to the passed in items and creates some grid-items out of them\nfunction buildComponents(components: IGridComponent<any>[]): ReactElement[] {\n  console.log(\"Components built\");\n\n  return components.map((comp: IGridComponent<any>, i) =>\n    createElement(comp.element, {\n      props: comp.props, // passed in props\n\n      // props for grid-itemsa\n      className: \"dashboard-component\",\n      key: comp.layout.i,\n      \"data-grid\": comp.layout\n    }, comp.children)\n  );\n}\n\nconst Dashboard: FunctionComponent<IDashboardProps> = (props: IDashboardProps) => {\n  const [audioManager, setaudioManager] = useState(new AudioManager());\n  const [dshbLayout, setDshbLayout] = useState([defaultDashboardLayout.temp1,defaultDashboardLayout.temp2]);\n  // execute on first build\n\n\n  // TODO: How often does this get built? is it a side-effect?\n  let builtElements: ReactElement[] = useMemo(() =>\n    buildComponents(dshbLayout)\n    , [dshbLayout]\n  );\n  console.timeLog(\"dashboard\");\n\n  // https://github.com/react-grid-layout/react-grid-layout\n  return (\n    <div className=\"dashboard\">\n      <ReactGridLayout className=\"grid\" {...gridProps}>\n        <Recorder className=\"dashboard-component\" audioManager={audioManager}\n          data-grid={recorderLayout} key={recorderLayout.i} />\n\n        {builtElements}\n      </ReactGridLayout>\n    </div >\n  );\n}\n\nexport default Dashboard;\n","import { FunctionComponent, useState } from \"react\";\nimport { ProSidebar, Menu, MenuItem, SidebarHeader, SidebarContent, SidebarFooter } from 'react-pro-sidebar';\n\nimport 'react-pro-sidebar/dist/css/styles.css';\nimport { TiPencil } from 'react-icons/ti';\nimport { GiAudioCassette } from 'react-icons/gi';\nimport { BiCodeCurly, BiArrowFromRight, BiArrowFromLeft } from 'react-icons/bi';\nimport { BsGear } from 'react-icons/bs';\n\n\nconst icons = {\n  menuClosed: <BiArrowFromLeft />,\n  menuOpen: <BiArrowFromRight />,\n  library: <GiAudioCassette />,\n  settings: <BsGear />,\n  sourceCode: <BiCodeCurly />,\n  contact: <TiPencil />,\n};\n\ninterface ISidebarProps {\n  isMobile?: boolean;\n}\n\nconst Sidebar: FunctionComponent<ISidebarProps> = (props: ISidebarProps) => {\n  // if it's mobile, start closed\n  const [isClosed, setIsClosed] = useState(props.isMobile == true);\n\n  // display properties\n  let title = isClosed ? \"BzJ\" : \"BazamJam\";\n  let width = props.isMobile ? \"20px\" : \"175px\";\n  let openCloseIcon = isClosed ? icons.menuClosed : icons.menuOpen;\n\n  // functions\n  let handleClose = () => setIsClosed(!isClosed);\n\n  // logic\n  if (props.isMobile && !isClosed) {\n    setIsClosed(true);\n  }\n\n  return (\n      <ProSidebar collapsed={isClosed} width={width}>\n\n        <SidebarHeader className=\"title-header\">\n          {title}\n        </SidebarHeader>\n\n        <SidebarContent>\n          <Menu iconShape=\"round\">\n            <MenuItem icon={icons.library}>\n              <a href=\"https://omfgdogs.com/\">Library</a>\n            </MenuItem>\n            <MenuItem icon={icons.settings}>\n            <a href=\"https://omfgdogs.com/\">Settings</a>\n            </MenuItem>\n            <MenuItem icon={openCloseIcon} onClick={handleClose}>\n              Minimize\n            </MenuItem>\n          </Menu>\n        </SidebarContent>\n\n        <SidebarFooter>\n          <Menu iconShape=\"round\">\n            <MenuItem icon={icons.contact}>\n              <a href=\"mailto:davidhaas6@gmail.com\">Contact</a>\n            </MenuItem>\n            <MenuItem icon={icons.sourceCode}>\n              <a href=\"https://github.com/davidhaas6/bazamjam\">Source</a>\n            </MenuItem>\n          </Menu>\n        </SidebarFooter>\n\n      </ProSidebar>\n  );\n}\n\nexport default Sidebar;","import  { FunctionComponent } from 'react';\nimport \"../assets/App.css\";\n\nimport Dashboard, { IGridComponent } from './Dashboard';\nimport Sidebar from './Sidebar';\n\n\ninterface IAppProps {\n  \n}\n \nconst App: FunctionComponent<IAppProps> = (props: IAppProps) => {\n\n\n  return (\n    <div className=\"App\">\n      <Sidebar />\n      <Dashboard />\n    </div>\n  );\n}\n\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}